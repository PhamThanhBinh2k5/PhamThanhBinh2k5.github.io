<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PhamThanhBinh â€” Bio</title>


  <style>
    /* Reset */
    * { box-sizing: border-box; margin: 0; padding: 0; }

    html,body { height: 100%; background: #000; font-family: Inter, system-ui, Arial, sans-serif; color: #fff; }

    /* Starfield (CSS) */
    body {
      background:
        radial-gradient(ellipse at bottom, rgba(10,8,20,0.85) 0%, rgba(3,2,10,0.8) 40%, rgba(1,1,8,0.7) 100%),
        linear-gradient(45deg, rgba(10,5,40,0.35), rgba(30,15,60,0.25));
      overflow: hidden;
    }

    /* A few layered star textures using box-shadow trick */
    .stars, .stars2, .stars3 {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      pointer-events: none;
      background: transparent;
      z-index: 0;
      opacity: 0.9;
      mix-blend-mode: screen;
    }
    .stars::after, .stars2::after, .stars3::after {
      content: '';
      position: absolute;
      width: 2px; height: 2px;
      border-radius: 50%;
      background: white;
      box-shadow: /* a generated dense cloud of pseudo-stars (small sample) */
        50vw 10vh #fff, 10vw 20vh #fff, 70vw 80vh #fff, 30vw 50vh #fff,
        90vw 60vh #fff, 5vw 75vh #fff, 40vw 10vh #fff, 60vw 30vh #fff,
        15vw 40vh #fff, 80vw 20vh #fff, 22vw 75vh #fff, 45vw 65vh #fff;
      opacity: 0.85;
      transform: translateZ(0);
      filter: blur(.3px);
    }
    /* second layer (smaller/farther) */
    .stars2::after { transform: scale(.6); opacity: 0.6; filter: blur(0.6px); }
    .stars3::after { transform: scale(.3); opacity: 0.45; filter: blur(1.2px); }

    /* Page layout */
    #wrap {
      position: relative;
      z-index: 2;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }
    .card {
      width: min(920px, 96%);
      max-width: 960px;
      display: grid;
      grid-template-columns: 420px 1fr;
      gap: 24px;
      align-items: center;
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));
      border-radius: 14px;
      padding: 20px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
      backdrop-filter: blur(6px) saturate(120%);
    }

    /* left column - 3D canvas container */
    #scene-holder {
      width: 100%;
      height: 420px;
      border-radius: 10px;
      overflow: hidden;
      background: linear-gradient(180deg, rgba(0,0,0,0.25), rgba(0,0,0,0.45));
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* right column - info and links */
    .info {
      padding: 4px 8px;
    }
    .avatar {
      width: 110px;
      height: 110px;
      border-radius: 50%;
      border: 3px solid rgba(255,255,255,0.12);
      object-fit: cover;
      display: inline-block;
      vertical-align: middle;
      margin-right: 14px;
    }
    h1 { font-size: 1.35rem; margin-bottom: 6px; }
    p.desc { color: #cfe6ff; opacity: 0.9; margin-bottom: 12px; }
    .links a {
      display: inline-block;
      margin: 6px 6px 6px 0;
      padding: 8px 12px;
      background: rgba(255,255,255,0.06);
      color: #fff;
      border-radius: 8px;
      text-decoration: none;
      font-weight: 600;
      transition: all .18s ease;
    }
    .links a:hover { transform: translateY(-3px); background: rgba(255,255,255,0.12); }

    /* responsive */
    @media (max-width: 880px) {
      .card { grid-template-columns: 1fr; }
      #scene-holder { height: 340px; }
      .avatar { margin-bottom: 10px; }
    }

    /* small instruction */
    .note { margin-top: 10px; color: rgba(255,255,255,0.6); font-size: 0.9rem; }
  </style>
</head>
<body>
  <!-- layered CSS stars -->
  <div class="stars"></div>
  <div class="stars2"></div>
  <div class="stars3"></div>

  <div id="wrap">
    <div class="card">
      <div id="scene-holder"></div>

      <div class="info">
        <!-- Put avatar.jpg in the repo root and it will appear here -->
        <div style="display:flex; align-items:center;">
    <img class="avatar" src="me.jpg" alt="me" onerror="this.style.display='none'">
  
          <div>
            <h1>2B_B</h1>
            <div class="note">Sinh viÃªn CNTT â€¢ Láº­p trÃ¬nh web â€¢ MusicProducer</div>
          </div>
        </div>
<div class="links">
          <a href="https://www.facebook.com/ThanhBinh6z" target="_blank">ðŸ“˜ Facebook</a>
          <a href="https://www.instagram.com/binh.thanhpham" target="_blank">ðŸ“¸ Instagram</a>
          <a href="https://github.com/PhamThanhBinh2k5" target="_blank">ðŸ’» GitHub</a>
        </div>

       
        <div class="note">LÆ°u Ã½: LiÃªn há»‡ cÃ´ng viá»‡c qua Gmail: ptb2k5@gmail.com <code></code> .</div>
      </div>
    </div>
  </div>

  <!-- Three.js tá»« CDN (phiÃªn báº£n á»•n Ä‘á»‹nh) -->
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.152.2/examples/js/controls/OrbitControls.js"></script>

  <script>
    // Scene setup
    const holder = document.getElementById('scene-holder');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, holder.clientWidth / holder.clientHeight, 0.1, 2000);
    camera.position.set(0, 0, 3.4);

    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(holder.clientWidth, holder.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    holder.appendChild(renderer.domElement);

    // lights
    const ambient = new THREE.AmbientLight(0xffffff, 0.35);
    scene.add(ambient);
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(5, 3, 5);
    scene.add(dir);

    // Earth group (sphere + clouds)
    const earthGroup = new THREE.Group();
    scene.add(earthGroup);

    // Create sphere geometry
    const geometry = new THREE.SphereGeometry(1, 64, 64);

    // texture loader
    const loader = new THREE.TextureLoader();

    // attempt to load 'earth.jpg' from repo root (recommended)
    loader.load(
      'earth.jpg',
      (tex) => {
        tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
        const mat = new THREE.MeshPhongMaterial({
          map: tex,
          shininess: 6
        });
        const earth = new THREE.Mesh(geometry, mat);
        earthGroup.add(earth);

        // subtle cloud layer (semi-transparent white)
        const cloudMat = new THREE.MeshLambertMaterial({
          map: null,
          transparent: true,
          opacity: 0.35,
          depthWrite: false
        });
        // try to load a clouds texture if exists
        loader.load('clouds.png',
          (cloudTex) => {
            cloudMat.map = cloudTex;
            const cloudMesh = new THREE.Mesh(new THREE.SphereGeometry(1.005, 64, 64), cloudMat);
            earthGroup.add(cloudMesh);
          },
          undefined,
          () => {
            // no clouds texture; add faint atmosphere using shader-like sphere
            const cloudMesh = new THREE.Mesh(new THREE.SphereGeometry(1.01, 32, 32),
              new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.035 }));
            earthGroup.add(cloudMesh);
          }
        );
      },
      undefined,
      // onError -> fallback
      () => {
        // fallback simple painted earth if no texture provided
        const canvas = document.createElement('canvas');
        canvas.width = canvas.height = 1024;
        const ctx = canvas.getContext('2d');

        // base blue
        ctx.fillStyle = '#2a6fb3';
        ctx.fillRect(0, 0, 1024, 1024);

        // draw simple landmasses (stylized)
        ctx.fillStyle = '#2b8a3e';
        ctx.beginPath();
        ctx.ellipse(420, 520, 220, 120, -0.4, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(650, 350, 180, 90, 0.2, 0, Math.PI * 2);
        ctx.fill();

        // subtle lighting
        const grd = ctx.createLinearGradient(0, 0, 1024, 0);
        grd.addColorStop(0, 'rgba(255,255,255,0.06)');
        grd.addColorStop(1, 'rgba(0,0,0,0.2)');
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, 1024, 1024);

        const tex = new THREE.CanvasTexture(canvas);
        const mat = new THREE.MeshPhongMaterial({ map: tex, shininess: 6 });
        const earth = new THREE.Mesh(geometry, mat);
        earthGroup.add(earth);
      }
    );

    // Add a subtle atmosphere glow (screen-space trick)
    const atmosphereGeo = new THREE.SphereGeometry(1.06, 64, 64);
    const atmosphereMat = new THREE.MeshBasicMaterial({
      color: 0x8fb5ff,
      transparent: true,
      opacity: 0.06,
      blending: THREE.AdditiveBlending
    });
    const atmosphere = new THREE.Mesh(atmosphereGeo, atmosphereMat);
    scene.add(atmosphere);

    // stars (small points)
    function addStarField(num = 1000, radius = 50) {
      const geom = new THREE.BufferGeometry();
      const positions = new Float32Array(num * 3);
      for (let i = 0; i < num; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos((Math.random() * 2) - 1);
        const r = radius * (0.5 + Math.random() * 0.5);
        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);
        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;
      }
      geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const mat = new THREE.PointsMaterial({ size: 0.024, color: 0xffffff, transparent: true, opacity: 0.9 });
      const points = new THREE.Points(geom, mat);
      scene.add(points);
    }
    addStarField(1200, 60);

    // controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.minDistance = 1.8;
    controls.maxDistance = 6.0;
    controls.autoRotate = false;

    // responsiveness
    window.addEventListener('resize', () => {
      renderer.setSize(holder.clientWidth, holder.clientHeight);
      camera.aspect = holder.clientWidth / holder.clientHeight;
      camera.updateProjectionMatrix();
    });

    // animate
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const t = clock.getElapsedTime();

      // slow rotation of earth group
      earthGroup.rotation.y = t * 0.12;
      // atmosphere gentle bob
      atmosphere.rotation.y = t * 0.08;

      controls.update();
      renderer.render(scene, camera);
    }
    // Sao bÄƒng
function createMeteor() {
  const meteor = document.createElement('div');
  meteor.style.position = 'fixed';
  meteor.style.width = '2px';
  meteor.style.height = '80px';
  meteor.style.background = 'linear-gradient(white, transparent)';
  meteor.style.opacity = '0.7';
  meteor.style.transform = 'rotate(45deg)';
  meteor.style.left = Math.random() * window.innerWidth + 'px';
  meteor.style.top = Math.random() * window.innerHeight * 0.5 + 'px';
  meteor.style.pointerEvents = 'none';
  meteor.style.zIndex = 1;
  document.body.appendChild(meteor);

  meteor.animate([
    { transform: 'translate(0, 0) rotate(45deg)', opacity: 0.8 },
    { transform: 'translate(-200px, 200px) rotate(45deg)', opacity: 0 }
  ], {
    duration: 1500,
    easing: 'ease-out'
  });

  setTimeout(() => meteor.remove(), 1500);
}

function animate() {
  requestAnimationFrame(animate);
  const t = clock.getElapsedTime();
  const delta = clock.getDelta();

  earthGroup.rotation.y = t * 0.12;
  atmosphere.rotation.y = t * 0.08;

  updateMeteors(delta); // cáº­p nháº­t sao bÄƒng
  controls.update();
  renderer.render(scene, camera);
}

  // hÆ°á»›ng Ã¡nh sÃ¡ng thay Ä‘á»•i theo vá»‹ trÃ­ chuá»™t
  dir.position.set(x * 5, y * 3, 5).normalize().multiplyScalar(5);
});

// === Sao bÄƒng tháº­t báº±ng Three.js ===
const meteors = [];

function spawnMeteor() {
  const geometry = new THREE.BufferGeometry();
  const positions = new Float32Array(6); // 2 Ä‘iá»ƒm (x1,y1,z1,x2,y2,z2)
  const startX = (Math.random() - 0.5) * 40;
  const startY = Math.random() * 20 + 10;
  const startZ = -30;

  const endX = startX - 10;
  const endY = startY - 10;
  const endZ = startZ + 20;

  positions.set([startX, startY, startZ, endX, endY, endZ]);
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

  const material = new THREE.LineBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.8,
  });

  const meteor = new THREE.Line(geometry, material);
  meteor.userData = { life: 1.0 };
  scene.add(meteor);
  meteors.push(meteor);
}

function updateMeteors(delta) {
  for (let i = meteors.length - 1; i >= 0; i--) {
    const m = meteors[i];
    m.position.x -= delta * 25;
    m.position.y -= delta * 25;
    m.position.z += delta * 40;
    m.userData.life -= delta * 1.2;
    m.material.opacity = m.userData.life;
    if (m.userData.life <= 0) {
      scene.remove(m);
      meteors.splice(i, 1);
    }
  }
}

// Táº¡o sao bÄƒng ngáº«u nhiÃªn má»—i vÃ i giÃ¢y
setInterval(() => {
  if (Math.random() > 0.7) spawnMeteor();
}, 2000);

  </script>
</body>
</html>
